### 버퍼 풀과 리두 로그 
> InnoDB 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있다. 
- InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라진다. 
- InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있는데, 버퍼 풀의 메모리 공간만 단순히 늘리는 것은 데이터 캐시 기능만 향상 시키는 것이다. 
- InnoDB 버퍼 풀은 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지와 함께 insert update delete 명령으로 변경된 데이터를 가진 더티 페이지도 가지고 있다.
- 더티 페이지는 버퍼 풀에 무한정 머무를 수 있는 것이 아니며 데이터 변경이 계속 발생하면 리두 로그 파일에 기록됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다 .
- 리두로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용한다.
- InnoDB 스토리지 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리해야되는데, **재사용 불가능한 공간을 활성 리두 로그 라고 한다.**
- 리두 로그 파일의 공간을 계속 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션은 계속 증가된 값을 가지게 되며 이를 LSN (Log Sequence Number)라고 부른다.
- LSN은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화하고 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 된다. 하지만 활성 리두 
  로그의 마지막은 계속해서 증가하기 때문에 체크포인트와 무관하다.
- 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN 차이를 체크포인트 에이지라고 한다. 즉 체크포인트 에이지는 활성 리두 로그 공간의 크기를 일컫는다. 
- InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지며 체크포인트가 발생하면 체크포인트 LSN 보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 한다. 
  LSN보다 작은 LSN 값을 가진 리두 로그 엔트리도 디스크로 동기화돼야 한다.

#### 예시 
1. 버퍼 풀 100GB 이면서 리두 로그 파일의 전체 크기는 100MB인 경우
2. 버퍼 풀 100MB 이면서 리두 로그 파일 전체의 크기는 100GB 인 경우 

- 1번의 경우 리두 로그 파일의 크기가 100MB밖에 안되기 때문에 체크포인트 에이지도 최대 100MB만 허용 된다 
- 2번의 경우 대략 400GB 정도의 더티 페이지를 가질 수 있다. 하지만 버퍼 풀의 크기가 100MB이기 때문에 최대 허용 가능한 더티 페이지는 100MB 크기가 된다. 

_리두로그는 무조건 크다고 좋은 것은 아니다. 공간이 크면 클수록 급작스러운 디스크 쓰기가 발생할 가능성이 높다. 버퍼 풀에 더티 페이지의 비율이 너무 높은 상태에서 갑자기 버퍼 풀이 필요해지는 상황이 오면 
InnoDB 스토리지 엔진은 매우 많은 더티 페이지를 한 번에 기록해야 하는 상황이 오기 때문에 버퍼풀의 크기가 100GB 이하의 MySQL 서버에서는 리두 로그 파일의 전체크기를 대략 5-10GB 수준으로 
선택하고 필요할 때마다 조금씩 늘려가면서 최적값을 찾는 것이 좋다_



### 버퍼 풀 플러시 (Buffer Pool Flush)
> 5.6버전 까지는 더티 페이지 플러시 기능이 부드럽지 않았다. 급작스러운 디스크 기록이 폭증해서 사용자 쿼리 처리 성능에 영향을 받는 경우가 많았다. 하지만 8.0 부터는 더티 페이지를 동기화하는 부분에서 예전과 같은 디스크 쓰기 폭증 현상은 발생하지 않는다. 
- InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음과 같이 2개의 플러시 기능을 백그라운드로 실행한다 . 
  1. 플러시 리스트 플러시
  2. LRU 리스트 플러시 

### 플러시 리스트 플러시 
> 스토리지 엔진은 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야한다. 이때 오래된 리두 로그 공간이 지워지려면 반드시 버퍼 풀의 더티 페이지가 먼저 디스크로 동기화돼야 한다. 
- 스토리지 엔진은 주기적으로 플러시 함수를 호출해 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다. 
- 언제부터 얼마나 많은 더티 페이지를 한 번에 디스크를 기록하느냐에 따라 쿼리 처리가 악형향을 받지 않으면서 부드럽게 처리된다. 이를 위해 스토리지 엔진은 다음과 같은 시스템 변수들을 제공한다 .
  1. innodb_page_cleaner: 스레드의 개수를 조정할 수 있으며 버퍼풀의 인스턴스 개수보다 많은 경우 설정값을 자동으로 변경한다.
  2. innodb_max_dirty_pages_pct_lwm: 더티 페이지 기본 값은 10%다 
  3. innodb_max_dirty_pages_pct: 더티 페이지의 비율을 조정. 더티 페이지를 많이 가질수록 쓰기 작업을 버퍼링함으로써 여러번의 디스크 쓰기를 한 번으로 줄이는 효과를 극대화할 수 있다 
     . 가능하면 기본값이 좋다 .
  4. innodb_io_capacity: 설정된 값을 기준으로 더티 페이지 쓰기를 실행한다. 디스크 쓰기가 많이 발생하고 더티 페이지의 비율이 너무 낮은 상태로 계속 머물러 있으면 lwm 시스템변수를 조금 
     더 높은 값으로 조정해야 디스크 쓰기 횟수를 줄이는 효과를 얻을 수 있다. 
  5. innodb_io_capacity_max: 디스크가 최대의 성능을 발휘할 때 어느 정도의 디스크 읽고 쓰기가 가능한지를 설정한다.(InnoDB 스토리지 엔진의 백그라운드 스레드가 수행하는 디스크 작업) 
  6. innodb_flush_neighbors: 더티 페이지를 디스크에 기록할 때 디스크에서 근접한 페이지 중에서 더티 페이지가 있다면 InnoDB 스토리지 엔진이 함게 묶어서 디스크로 기록하게 해주는 
     기능을 활성화할지 결정한다. (데이터베이스 서버들이 한 번이라도 디스크 읽고 쓰기를 줄이기 위해) 데이터 저장을 하드디스크로 하고 있으면 1 또는 2로 설정해서 활성화하는 것이 좋지만 요즘은 대부분 
     솔리드 스테이트 드라이브(SSD)를 사용하기 때문에 기본값이 비활성 모드로 유지하는 것이 좋다 
  7. innodb_adaptive_flushing: 서버의 트래픽을 보면서 capacity 와 capacity_max를 설정하는 것이 번거울 때 버퍼 풀의 더티 페이지 비율이나 설정값에 의존하지 않고 
     새로운 알고리즘을 사용한다. 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기를 실행한다. (전체 리두 로그 공간에서 공간이 10를 넘어설때 
     어댑티브 플러시 알고리즘이 작동한다)
  8. innodb_adaptive_flushing_lwm



### LRU 리스트 플러시 
> LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야한다 . 이때 LRU 리스트 플러시 함수가 사용된다.
- 스토리지 엔진은 LRU 리스트의 끝부분부터 시작해서 최대 innodb_lru_scan_depth 시스템 변수에 설정된 개수만큼의 페이지들을 스캔한다.
- 스토리지 엔진은 이때 스캔하면서 더티페이지는 디스크에 동기화하게 하며, 클린 페이지는 즉시 프리 리스트로 페이지를 옮긴다. 

### 버퍼 풀 상태 백업 및 복구 
> InnoDB 서버의 버퍼 풀은 쿼리의 성능에 매우 밀접하게 연결돼 있다. 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태를 워밍업이라고 표현한다. 워밍업된 상태에서는 그렇지 않은 경우보다 몇십 배의 쿼리 
처리속도를 보이는 것이 일반적이다.
>
- 서버를 셧다운했다가 다시 시작하고 서비스를 시작하면 쿼리 처리 성능이 평상시보다 1/10도 안 되는 경우가 대부분인데 그 이유는 버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비돼 있으므로 디스크에서 데이터를 
  읽지 않아도 쿼리가 처리될 수 있기 때문이다. 
- 5.6 버전부터는 버퍼 풀 덤프 및 적재 기능이 도입됐다. 서버 점검이나 기타 작업을 위해 MySQL 서버를 재시작해야 하는 경우 `innodb_buffer_pool_dump_now` 시스템 변수를 이용해 
  현재 InnoDB 버퍼 풀의 상태를 백업할 수 있다. 서버를 다시 시작하면 `innodb_buffer_pool_load_now` 변수를 이용해 버퍼 풀의 상태를 다시 복구가 가능하다. 
```shell
// 서버 재시작 전 버퍼 풀 상태 백업 
SET GLOBAL innodb_buffer_pool_dump_now=ON;
// 서버 재시작 후 버퍼 풀 상태 복구 
SET GLOBAL innodb_buffer_pool_load_now=ON;
```

- 버퍼 풀의 백업은 데이터 디렉터리에 `ib_buffer_pool`이라는 이름의 파일로 생성된다. 크기는 몇십 MB 이하 이다. 
  - LRU 리스트에서 적재된 데이터 페이지의 메타 정보만 가져와서 저장하기 때문이다. 그렇기 때문에 버퍼 풀의 백업은 매우 빨리 완료된다.
- 버퍼 풀의 내용을 다시 버퍼 풀로 복구하는 과정을 크기에 따라 상당한 시간이 걸린다. 그 이유는 백업된 **내용을 각 테이블의 데이터 페이지를 다시 리스크에서 읽어와야하기 때문이다 .** 
    - 상당히 오래걸릴시 중간에 멈추고자 할땐 `innodb_buffer_pool_load_abort` 변수를 이용하면 된다. 
- 이러한 작업은 전반적으로 수동적인데 자동으로 셧다운 되기전 버퍼 풀의 백업을 실행하고 버퍼 풀의 백업과 복구를 자동화하려면 아래와 같은 시스템 변수를 이용하면 된다 
  - `innodb_buffer_pool_dump_at_shutdown`
  - `innodb_buffer_ppol_load_at_startup`
  - 설정을 MySql 설정 파일에 넣어두면 된다. 

### 버퍼 풀의 적재 내용 확인 
> 5.6 버전 부터는 서버의 information_schema 를 통해 어떤 테이블의 페이지들이 적재돼 있는지 확인 할 수 있었는데, 8.0 부터는 information_schema 데이터베이스에 innodb_cached_indexes 테이블이 새로 추가됐다. 이 테이블을 이용하면 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인할 수 있다 .
> 
- 서버는 개별 인덱스별로 전체 개수가 몇 개인지 사용자에게 알려주지 않아서, information_schema의 테이블을 이용해도 테이블의 인덱스별로 페이지가 InnoDB 버퍼 풀에 적재된 비율은 확인할 수 
  가 없다.
```shell
SELECT 
  it.name table_name,
  ii.name index_name,
  ici.n_cached_pages n_chched_pages 
FROM information_schema.innodb_tables it 
  inner join information_schema.innodb_indexes ii on ii.table_id = it.table_id
  inner join information_schema.innodb_cached_indexes ici on ici.index_id=ii.index_id 
WHERE it.name =CONCAT('employees','/','employees')
```



### Double Write Buffer 
> 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기위해 페이지의 변경된 내용만 기록한다. 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하고 복구할 수 없을 수도 있으며 이러한 현상을 파셜 페이지, 톤 페이지라고 하는데 이런 현상들이 하드웨어의 오작동이나 시스템의 비정상 종료등으로 발생할 수 있는데 이러한 문제를 막기 위해 Double Write 기법을 사용한다.
![스크린샷 2024-01-21 오후 10.05.54.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-01-21%20%EC%98%A4%ED%9B%84%2010.05.54.png)
- 위의 사진의 동작의 설명 
    1. A - E 까지 더티페이지를 디스크로 플러시한다고 가정할때 
    2. 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에 A - E 까지의 더티 페이지를 우선 묶는다 . 
  3. 한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록한다. 
  4. 스토리지 엔진은 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다. 
- DoubleWrite 버퍼내용은 중간에 실패할 때 목적으로 사용한다 . 
    1. A와 B 페이지에는 정상적으로 기록됐지만 C 페이지엔 기록되는 도중에 운영체제가 비정상적으로 종료됐을 때 
    2. 스토리지 엔진은 재시작 될 때 항상 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사한다. 
    3. 재시작될 때 항상 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교해서 다른 내용을 담고 있는 페이지가 있으면 데이터 파일의 페이지로 복사한다. 
    4. DoubleWrite 기능을 사용할지 여부는 `innodb_doublewrite` 시스템 변수로 제어할 수 있다 .
- 주로 데이터의 안전성을 위해 자주 사용한다. 
- 데이터의 무결성이 매우 중요한 서비스에는 DoubleWrite 활성화를 고려하는 것이 좋다. 
  - InnoDB 리두 로그 동기화설정을 1이 아닌 값으로 했다면 DoubleWrite도 비활성화하는 것이 좋다. 
  - 리두로그를 항상 동기화해라

